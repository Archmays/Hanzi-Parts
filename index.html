<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>æ±‰å­—é­”æ³•æˆ˜-åæ—éƒ¨é¦–</title>
  
  <!-- å¼•å…¥ Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- å¼•å…¥ Babel ç”¨äºè§£æ JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* è‡ªå®šä¹‰åŠ¨ç”»æ ·å¼ */
    @keyframes shake {
      10%, 90% { transform: translate3d(-1px, 0, 0); }
      20%, 80% { transform: translate3d(2px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
      40%, 60% { transform: translate3d(4px, 0, 0); }
    }
    .shake-animation { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
    
    @keyframes float-up {
      0% { transform: translate(-50%, 0) scale(0.5); opacity: 0; }
      20% { transform: translate(-50%, -40px) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -100px) scale(1); opacity: 0; }
    }
    .animate-float-up { animation: float-up 0.8s ease-out forwards; }
    
    @keyframes bounce-slow {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5%); }
    }
    .animate-bounce-slow { animation: bounce 3s infinite; }

    /* éšè—æ»šåŠ¨æ¡ä½†ä¿ç•™åŠŸèƒ½ */
    .no-scrollbar::-webkit-scrollbar { display: none; }
    .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
  </style>
</head>
<body class="bg-stone-100 text-stone-800 overflow-hidden select-none touch-manipulation">
  <div id="root"></div>

  <!-- ä½¿ç”¨ type="text/babel" å’Œ data-type="module" æ¥æ”¯æŒ ESM å¯¼å…¥ -->
  <script type="text/babel" data-type="module">
    // ä» esm.sh å¯¼å…¥ React å’Œä¾èµ–ï¼Œè¿™æ¯” UMD æ›´ç¨³å®š
    import React, { useState, useEffect, useCallback, useRef } from 'https://esm.sh/react@18.2.0';
    import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';
    import { 
      Heart, Sword, Shield, Trophy, BookOpen, 
      Lightbulb, Home, Zap, Flame, Droplets, Mountain,
      FileText, X, Star, Sparkles, MoveRight, Layers, Box,
      Play, RotateCcw, SkipForward, HelpCircle,
      Volume2, VolumeX 
    } from 'https://esm.sh/lucide-react@0.263.1';

    // --- 1. æ ¸å¿ƒæ•°æ®å®šä¹‰ ---

    // è§’è‰²å®šä¹‰
    const CHARACTERS = [
      {
        id: 'warrior',
        name: 'èµ¤ç‚ä¾ ',
        desc: 'æ”»å‡»å‹ã€‚åŸºç¡€ä¼¤å®³+5ã€‚',
        icon: <Flame className="text-red-500" />,
        hpBonus: 0,
        dmgBonus: 5,
        skillName: 'çƒˆç«æ–©',
        skillDesc: 'é€ æˆ20ç‚¹ç«å±æ€§ä¼¤å®³',
        skillCost: 3, 
        skillEffect: (gameState) => ({ monsterHp: Math.max(0, gameState.monsterHp - 20) })
      },
      {
        id: 'scholar',
        name: 'å¢¨çµå¸ˆ',
        desc: 'æŠ€å·§å‹ã€‚æ¯å›åˆå›è¡€+2ã€‚',
        icon: <Droplets className="text-blue-500" />,
        hpBonus: -10, 
        dmgBonus: 0,
        handSizeBonus: 1,
        skillName: 'å‡ç¥',
        skillDesc: 'æ¢å¤15ç‚¹ç”Ÿå‘½å€¼',
        skillCost: 3,
        skillEffect: (gameState) => ({ playerHp: Math.min(gameState.maxPlayerHp, gameState.playerHp + 15) })
      },
      {
        id: 'tank',
        name: 'é“ç¬”å«',
        desc: 'é˜²å¾¡å‹ã€‚åˆå§‹è¡€é‡+30ã€‚',
        icon: <Mountain className="text-amber-700" />,
        hpBonus: 30,
        dmgBonus: -2, 
        skillName: 'é“å£',
        skillDesc: 'å›å¤10è¡€å¹¶è·å¾—é˜²å¾¡',
        skillCost: 4,
        skillEffect: (gameState) => ({ playerHp: Math.min(gameState.maxPlayerHp + 30, gameState.playerHp + 10) }) 
      }
    ];

    // æ€ªç‰©å®šä¹‰
    const MONSTER_TYPES = [
      { name: 'å¢¨è¿¹å¦–', icon: 'ğŸ‘¾', desc: 'æ€•æ°´æ¸…æ´—', hpScale: 1.2, weakness: 'water' },
      { name: 'é”™åˆ«é¬¼', icon: 'ğŸ‘»', desc: 'æ€•ç”¨å¿ƒæ£€æŸ¥', hpScale: 1.5, weakness: 'mind' },
      { name: 'æ¶‚é¸¦æ€ª', icon: 'ğŸ‘º', desc: 'æ€•è¢«æ“¦é™¤(åœŸæ©)', hpScale: 1.0, weakness: 'earth' },
      { name: 'ç”Ÿåƒ»å…½', icon: 'ğŸ²', desc: 'æ— å¼±ç‚¹', hpScale: 2.0, weakness: 'none' },
    ];

    // è¾…åŠ©å‡½æ•°ï¼šç”ŸæˆKey
    const k = (...args) => args.sort().join('');

    // ç»„åˆå­—å…¸
    const COMBINATION_DB = {
      // === å·¦å³ç»“æ„ (lr) ===
      [k('è® ','æ­£')]: { char: 'è¯', power: 15, desc: 'è¯æ®', type: 'mind', struct: 'lr' },
      [k('æ°µ','å·¥')]: { char: 'æ±Ÿ', power: 15, desc: 'æ±Ÿæ°´', type: 'water', struct: 'lr' },
      [k('æ°µ','å¯')]: { char: 'æ²³', power: 15, desc: 'æ²³æµ', type: 'water', struct: 'lr' },
      [k('æ°µ','èƒ¡')]: { char: 'æ¹–', power: 15, desc: 'æ¹–æ³Š', type: 'water', struct: 'lr' },
      [k('æ°µ','æ¯')]: { char: 'æµ·', power: 15, desc: 'å¤§æµ·', type: 'water', struct: 'lr' },
      [k('æ°µ','ç¾Š')]: { char: 'æ´‹', power: 15, desc: 'æµ·æ´‹', type: 'water', struct: 'lr' },
      [k('æ°µ','å¹²')]: { char: 'æ±—', power: 15, desc: 'æ±—æ°´', type: 'water', struct: 'lr' },
      [k('æ°µ','ç›®')]: { char: 'æ³ª', power: 15, desc: 'çœ¼æ³ª', type: 'water', struct: 'lr' },
      [k('æ°µ','å…ˆ')]: { char: 'æ´—', power: 15, desc: 'æ¸…æ´—', type: 'water', struct: 'lr' },
      [k('æ°µ','æ°”')]: { char: 'æ±½', power: 15, desc: 'æ±½æ°´', type: 'water', struct: 'lr' },
      [k('æ°µ','æ°¸')]: { char: 'æ³³', power: 15, desc: 'æ¸¸æ³³', type: 'water', struct: 'lr' },
      [k('æ°µ','å°‘')]: { char: 'æ²™', power: 15, desc: 'æ²™å­', type: 'earth', struct: 'lr' },
      [k('æ°µ','èˆŒ')]: { char: 'æ´»', power: 15, desc: 'ç”Ÿæ´»', type: 'life', struct: 'lr' },
      [k('æ°µ','å»')]: { char: 'æ³•', power: 15, desc: 'åŠæ³•', type: 'mind', struct: 'lr' },
      [k('æ°µ','ç‚')]: { char: 'æ·¡', power: 15, desc: 'å¹³æ·¡', type: 'water', struct: 'lr' },
      [k('æ°µ','ä¸»')]: { char: 'æ³¨', power: 15, desc: 'æ³¨æ„', type: 'mind', struct: 'lr' },

      [k('äº»','å°”')]: { char: 'ä½ ', power: 12, desc: 'ä½ æˆ‘', type: 'normal', struct: 'lr' },
      [k('äº»','ä¹Ÿ')]: { char: 'ä»–', power: 12, desc: 'ä»–äºº', type: 'normal', struct: 'lr' },
      [k('äº»','é—¨')]: { char: 'ä»¬', power: 12, desc: 'æˆ‘ä»¬', type: 'normal', struct: 'lr' },
      [k('äº»','å')]: { char: 'ä»€', power: 12, desc: 'ä»€ä¹ˆ', type: 'normal', struct: 'lr' },
      [k('äº»','æ•…')]: { char: 'åš', power: 15, desc: 'åšäº‹', type: 'action', struct: 'lr' },
      [k('äº»','ä¹')]: { char: 'ä½œ', power: 15, desc: 'ä½œä¸š', type: 'action', struct: 'lr' },
      [k('äº»','è¨€')]: { char: 'ä¿¡', power: 15, desc: 'ç›¸ä¿¡', type: 'mind', struct: 'lr' },
      [k('äº»','æ—¦')]: { char: 'ä½†', power: 12, desc: 'ä½†æ˜¯', type: 'normal', struct: 'lr' },
      [k('äº»','éŸ¦')]: { char: 'ä¼Ÿ', power: 18, desc: 'ä¼Ÿå¤§', type: 'epic', struct: 'lr' },
      [k('äº»','å‘†')]: { char: 'ä¿', power: 15, desc: 'ä¿æŠ¤', type: 'defense', struct: 'lr' },
      [k('äº»','æ‰')]: { char: 'å', power: 12, desc: 'åå¿ƒ', type: 'normal', struct: 'lr' },
      [k('äº»','è±¡')]: { char: 'åƒ', power: 15, desc: 'å¥½åƒ', type: 'normal', struct: 'lr' },
      [k('äº»','äº­')]: { char: 'åœ', power: 12, desc: 'åœæ­¢', type: 'action', struct: 'lr' },
      [k('äº»','å°¤')]: { char: 'ä¼˜', power: 18, desc: 'ä¼˜ç§€', type: 'good', struct: 'lr' },
      [k('äº»','å')]: { char: 'ä½¿', power: 12, desc: 'ä½¿ç”¨', type: 'action', struct: 'lr' },

      [k('æ‰Œ','ä¸')]: { char: 'æ‰“', power: 15, desc: 'æ‰“å‡»', type: 'attack', struct: 'lr' },
      [k('æ‰Œ','åŒ…')]: { char: 'æŠ±', power: 12, desc: 'æ‹¥æŠ±', type: 'action', struct: 'lr' },
      [k('æ‰Œ','å·´')]: { char: 'æŠŠ', power: 12, desc: 'æŠŠæ¡', type: 'action', struct: 'lr' },
      [k('æ‰Œ','çˆª')]: { char: 'æŠ“', power: 15, desc: 'æŠ“ä½', type: 'action', struct: 'lr' },
      [k('æ‰Œ','å°‘')]: { char: 'æŠ„', power: 12, desc: 'æŠ„å†™', type: 'action', struct: 'lr' },
      [k('æ‰Œ','æˆ·')]: { char: 'æŠ¤', power: 15, desc: 'çˆ±æŠ¤', type: 'defense', struct: 'lr' },
      [k('æ‰Œ','æ—¦')]: { char: 'æ‹…', power: 12, desc: 'æ‰æ‹…', type: 'action', struct: 'lr' },
      [k('æ‰Œ','æ—¨')]: { char: 'æŒ‡', power: 12, desc: 'æŒ‡ç¤º', type: 'action', struct: 'lr' },
      [k('æ‰Œ','å¯º')]: { char: 'æŒ', power: 12, desc: 'åšæŒ', type: 'action', struct: 'lr' },
      [k('æ‰Œ','åœ­')]: { char: 'æŒ‚', power: 12, desc: 'æŒ‚ä»¶', type: 'action', struct: 'lr' },
      [k('æ‰Œ','å“')]: { char: 'æ‰', power: 12, desc: 'æ‰è½', type: 'action', struct: 'lr' },
      [k('æ‰Œ','åœ')]: { char: 'æ‰‘', power: 15, desc: 'æ‰‘ç­', type: 'attack', struct: 'lr' },
      [k('æ‰Œ','ä¹ƒ')]: { char: 'æ‰”', power: 15, desc: 'æ‰”çƒ', type: 'attack', struct: 'lr' },
      [k('ç¦¾','å¸Œ')]: { char: 'ç¨€', power: 15, desc: 'ç¨€å°‘', type: 'normal', struct: 'lr' }, 
      [k('æ‰Œ','éš¹')]: { char: 'æ¨', power: 15, desc: 'æ¨åŠ¨', type: 'action', struct: 'lr' },
      [k('æ‰Œ','å¦¾')]: { char: 'æ¥', power: 12, desc: 'æ¥å—', type: 'normal', struct: 'lr' },

      [k('è® ','å')]: { char: 'è®¡', power: 15, desc: 'è®¡ç®—', type: 'mind', struct: 'lr' },
      [k('è® ','ä¸')]: { char: 'è®¢', power: 12, desc: 'è®¢å•', type: 'normal', struct: 'lr' },
      [k('è® ','äºº')]: { char: 'è®¤', power: 12, desc: 'è®¤è¯†', type: 'mind', struct: 'lr' },
      [k('è® ','ä¸Š')]: { char: 'è®©', power: 12, desc: 'è®©æ­¥', type: 'normal', struct: 'lr' },
      [k('è® ','åª')]: { char: 'è¯†', power: 12, desc: 'çŸ¥è¯†', type: 'mind', struct: 'lr' },
      [k('è® ','ä¹‰')]: { char: 'è®®', power: 12, desc: 'è®®è®º', type: 'normal', struct: 'lr' },
      [k('è® ','å·±')]: { char: 'è®°', power: 15, desc: 'è®°å¿†', type: 'mind', struct: 'lr' },
      [k('è® ','äº•')]: { char: 'è®²', power: 12, desc: 'è®²è¯', type: 'sound', struct: 'lr' },
      [k('è® ','åˆ')]: { char: 'è®¸', power: 12, desc: 'è®¸å¤š', type: 'normal', struct: 'lr' },
      [k('è® ','å…‘')]: { char: 'è¯´', power: 12, desc: 'è¯´è¯', type: 'sound', struct: 'lr' },
      [k('è® ','å–')]: { char: 'è¯»', power: 15, desc: 'è¯»ä¹¦', type: 'mind', struct: 'lr' },
      [k('è® ','å¯º')]: { char: 'è¯—', power: 18, desc: 'è¯—æ­Œ', type: 'good', struct: 'lr' },
      [k('è® ','å¾')]: { char: 'è¯­', power: 15, desc: 'è¯­è¨€', type: 'sound', struct: 'lr' },
      [k('è® ','å°„')]: { char: 'è°¢', power: 15, desc: 'è°¢è°¢', type: 'good', struct: 'lr' },
      [k('è® ','é’')]: { char: 'è¯·', power: 12, desc: 'è¯·å®¢', type: 'normal', struct: 'lr' },
      [k('è® ','æœ')]: { char: 'è¯¾', power: 15, desc: 'ä¸Šè¯¾', type: 'mind', struct: 'lr' },

      [k('æœ¨','å¯¸')]: { char: 'æ‘', power: 12, desc: 'æ‘åº„', type: 'wood', struct: 'lr' },
      [k('æœ¨','æ‰')]: { char: 'æ', power: 15, desc: 'ææ–™', type: 'wood', struct: 'lr' },
      [k('æœ¨','å')]: { char: 'æ¿', power: 12, desc: 'æœ¨æ¿', type: 'wood', struct: 'lr' },
      [k('æœ¨','åŠ')]: { char: 'æ', power: 18, desc: 'æè‡´', type: 'epic', struct: 'lr' },
      [k('æœ¨','æ”¯')]: { char: 'æ', power: 12, desc: 'æ ‘æ', type: 'wood', struct: 'lr' },
      [k('æœ¨','ä¸')]: { char: 'æ¯', power: 12, desc: 'æ¯å­', type: 'normal', struct: 'lr' },
      [k('æœ¨','é£')]: { char: 'æ«', power: 15, desc: 'æ«å¶', type: 'wood', struct: 'lr' },
      [k('æœ¨','å‡ ')]: { char: 'æœº', power: 15, desc: 'æœºå™¨', type: 'tech', struct: 'lr' },
      [k('æœ¨','äº¤')]: { char: 'æ ¡', power: 15, desc: 'å­¦æ ¡', type: 'mind', struct: 'lr' },
      [k('æœ¨','å¯')]: { char: 'æŸ³', power: 15, desc: 'æŸ³æ ‘', type: 'wood', struct: 'lr' },
      [k('æœ¨','å¯¹')]: { char: 'æ ‘', power: 15, desc: 'å¤§æ ‘', type: 'wood', struct: 'lr' },
      [k('æœ¨','æ˜†')]: { char: 'æ£', power: 18, desc: 'æ£æ£’', type: 'attack', struct: 'lr' },
      [k('æœ¨','å¸›')]: { char: 'æ£‰', power: 15, desc: 'æ£‰èŠ±', type: 'normal', struct: 'lr' },
      [k('æœ¨','è‰®')]: { char: 'æ ¹', power: 15, desc: 'æ ‘æ ¹', type: 'wood', struct: 'lr' },
      [k('æœ¨','æ—')]: { char: 'å½¬', power: 18, desc: 'å½¬å½¬æœ‰ç¤¼', type: 'good', struct: 'lr' },

      [k('å£','æ˜Œ')]: { char: 'å”±', power: 15, desc: 'å”±æ­Œ', type: 'sound', struct: 'lr' },
      [k('å£','ä¹')]: { char: 'åƒ', power: 15, desc: 'åƒé¥­', type: 'heal', struct: 'lr' },
      [k('å£','æ–¤')]: { char: 'å¬', power: 15, desc: 'å¬è®²', type: 'mind', struct: 'lr' },
      [k('å£','æ¬ ')]: { char: 'å¹', power: 12, desc: 'å¹é£', type: 'sound', struct: 'lr' },
      [k('å£','å')]: { char: 'å¶', power: 12, desc: 'å¶å­', type: 'wood', struct: 'lr' },
      [k('å£','å°¼')]: { char: 'å‘¢', power: 10, desc: 'è¯­æ°”è¯', type: 'normal', struct: 'lr' },
      [k('å£','é‚£')]: { char: 'å“ª', power: 10, desc: 'å“ªé‡Œ', type: 'normal', struct: 'lr' },
      [k('å£','ç‰™')]: { char: 'å‘€', power: 10, desc: 'è¯­æ°”è¯', type: 'normal', struct: 'lr' },
      [k('å£','æœª')]: { char: 'å‘³', power: 15, desc: 'å‘³é“', type: 'normal', struct: 'lr' },
      [k('å£','äº¢')]: { char: 'å­', power: 12, desc: 'å­å£°', type: 'sound', struct: 'lr' },

      [k('å¥³','å­')]: { char: 'å¥½', power: 20, desc: 'ç¾å¥½', type: 'heal', struct: 'lr' },
      [k('å¥³','é©¬')]: { char: 'å¦ˆ', power: 15, desc: 'å¦ˆå¦ˆ', type: 'good', struct: 'lr' },
      [k('å¥³','ä¹ƒ')]: { char: 'å¥¶', power: 15, desc: 'å¥¶å¥¶', type: 'heal', struct: 'lr' },
      [k('å¥³','ä¸”')]: { char: 'å§', power: 15, desc: 'å§å§', type: 'normal', struct: 'lr' },
      [k('å¥³','æœª')]: { char: 'å¦¹', power: 15, desc: 'å¦¹å¦¹', type: 'normal', struct: 'lr' },
      [k('å¥³','å¤')]: { char: 'å§‘', power: 15, desc: 'å§‘å¨˜', type: 'normal', struct: 'lr' },
      [k('å¥³','ä¹Ÿ')]: { char: 'å¥¹', power: 12, desc: 'å¥¹', type: 'normal', struct: 'lr' },
      [k('å¥³','å°‘')]: { char: 'å¦™', power: 18, desc: 'å¥‡å¦™', type: 'good', struct: 'lr' },
      [k('å¥³','ä¹”')]: { char: 'å¨‡', power: 15, desc: 'å¨‡æ°”', type: 'normal', struct: 'lr' },
      [k('å¥³','èƒ¥')]: { char: 'å©¿', power: 15, desc: 'å¥³å©¿', type: 'normal', struct: 'lr' },

      [k('åœŸ','ä¹Ÿ')]: { char: 'åœ°', power: 15, desc: 'å¤§åœ°', type: 'earth', struct: 'lr' },
      [k('åœŸ','é¬¼')]: { char: 'å—', power: 15, desc: 'çŸ³å—', type: 'earth', struct: 'lr' },
      [k('åœŸ','ä¸')]: { char: 'å', power: 15, desc: 'åäºº', type: 'attack', struct: 'lr' },
      [k('åœŸ','çš®')]: { char: 'å¡', power: 15, desc: 'å±±å¡', type: 'earth', struct: 'lr' },
      [k('åœŸ','ç”³')]: { char: 'å¤', power: 20, desc: 'ä¹¾å¤', type: 'epic', struct: 'lr' },

      // === ä¸Šä¸‹ç»“æ„ (tb) ===
      [k('è‰¹','åŒ–')]: { char: 'èŠ±', power: 15, desc: 'èŠ±æœµ', type: 'wood', struct: 'tb' },
      [k('è‰¹','æ—©')]: { char: 'è‰', power: 15, desc: 'å°è‰', type: 'wood', struct: 'tb' },
      [k('è‰¹','é‡‡')]: { char: 'èœ', power: 15, desc: 'è”¬èœ', type: 'heal', struct: 'tb' },
      [k('è‰¹','ç”°')]: { char: 'è‹—', power: 12, desc: 'ç¦¾è‹—', type: 'wood', struct: 'tb' },
      [k('è‰¹','ç‰™')]: { char: 'èŠ½', power: 12, desc: 'å‘èŠ½', type: 'wood', struct: 'tb' },
      [k('è‰¹','å¹³')]: { char: 'è‹¹', power: 15, desc: 'è‹¹æœ', type: 'heal', struct: 'tb' },
      [k('è‰¹','å¤')]: { char: 'è‹¦', power: 15, desc: 'è¾›è‹¦', type: 'normal', struct: 'tb' },
      [k('è‰¹','ä½™')]: { char: 'èŒ¶', power: 15, desc: 'å–èŒ¶', type: 'heal', struct: 'tb' },
      [k('è‰¹','æ±¤')]: { char: 'è¡', power: 15, desc: 'è¡æ¼¾', type: 'water', struct: 'tb' },
      [k('è‰¹','å®£')]: { char: 'è±', power: 15, desc: 'è±è‰', type: 'wood', struct: 'tb' },
      [k('è‰¹','å¤®')]: { char: 'è‹±', power: 18, desc: 'è‹±é›„', type: 'good', struct: 'tb' },
      [k('è‰¹','åˆ†')]: { char: 'èŠ¬', power: 15, desc: 'èŠ¬èŠ³', type: 'wood', struct: 'tb' },
      [k('è‰¹','æ–¹')]: { char: 'èŠ³', power: 15, desc: 'èŠ³é¦™', type: 'wood', struct: 'tb' },
      [k('è‰¹','èŠ‚')]: { char: 'èŠ‚', power: 15, desc: 'èŠ‚æ—¥', type: 'normal', struct: 'tb' },
      [k('è‰¹','ä¹™')]: { char: 'è‰º', power: 15, desc: 'è‰ºæœ¯', type: 'mind', struct: 'tb' },

      [k('å®€','ç‰')]: { char: 'å®', power: 20, desc: 'å®è´', type: 'gold', struct: 'tb' },
      [k('å®€','è±•')]: { char: 'å®¶', power: 15, desc: 'å®¶åº­', type: 'defense', struct: 'tb' },
      [k('å®€','å¥³')]: { char: 'å®‰', power: 15, desc: 'å®‰å…¨', type: 'defense', struct: 'tb' },
      [k('å®€','å­')]: { char: 'å­—', power: 15, desc: 'æ±‰å­—', type: 'mind', struct: 'tb' },
      [k('å®€','å…ƒ')]: { char: 'å®Œ', power: 15, desc: 'å®Œæˆ', type: 'normal', struct: 'tb' },
      [k('å®€','è°·')]: { char: 'å®¹', power: 15, desc: 'å®¹æ˜“', type: 'normal', struct: 'tb' },
      [k('å®€','å„')]: { char: 'å®¢', power: 15, desc: 'å®¢äºº', type: 'normal', struct: 'tb' },
      [k('å®€','ä¸')]: { char: 'å®', power: 15, desc: 'å®‰å®', type: 'heal', struct: 'tb' },
      [k('å®€','ç”³')]: { char: 'å®¡', power: 15, desc: 'å®¡æŸ¥', type: 'mind', struct: 'tb' },
      [k('å®€','æœ¨')]: { char: 'å®‹', power: 12, desc: 'å®‹æœ', type: 'normal', struct: 'tb' },
      [k('å®€','å®…')]: { char: 'å®…', power: 12, desc: 'ä½å®…', type: 'earth', struct: 'tb' },
      [k('å®€','è§')]: { char: 'è§‰', power: 15, desc: 'æ„Ÿè§‰', type: 'mind', struct: 'tb' },
      [k('å®€','å¥‡')]: { char: 'å¯„', power: 15, desc: 'å¯„ä¿¡', type: 'action', struct: 'tb' },
      [k('å®€','å¯¸')]: { char: 'å®ˆ', power: 18, desc: 'å®ˆæŠ¤', type: 'defense', struct: 'tb' },
      [k('å®€','å•')]: { char: 'å®«', power: 18, desc: 'å®«æ®¿', type: 'epic', struct: 'tb' },

      [k('âº®','æ¯›')]: { char: 'ç¬”', power: 15, desc: 'æ¯›ç¬”', type: 'mind', struct: 'tb' },
      [k('âº®','å®˜')]: { char: 'ç®¡', power: 15, desc: 'ç®¡ç†', type: 'mind', struct: 'tb' },
      [k('âº®','å¹²')]: { char: 'ç«¿', power: 12, desc: 'ç«¹ç«¿', type: 'wood', struct: 'tb' },
      [k('âº®','åˆ')]: { char: 'ç­”', power: 15, desc: 'å›ç­”', type: 'sound', struct: 'tb' },
      [k('âº®','å¯º')]: { char: 'ç­‰', power: 12, desc: 'ç­‰å¾…', type: 'time', struct: 'tb' },
      [k('âº®','æœ¬')]: { char: 'ç¬¨', power: 10, desc: 'ç¬¨æ‹™', type: 'normal', struct: 'tb' },
      [k('âº®','å¤­')]: { char: 'ç¬‘', power: 15, desc: 'å¾®ç¬‘', type: 'heal', struct: 'tb' },
      [k('âº®','åŒ¡')]: { char: 'ç­', power: 12, desc: 'ç«¹ç­', type: 'normal', struct: 'tb' },
      [k('âº®','é—´')]: { char: 'ç®€', power: 15, desc: 'ç®€å•', type: 'normal', struct: 'tb' },
      [k('âº®','æ—¬')]: { char: 'ç¬‹', power: 15, desc: 'ç«¹ç¬‹', type: 'wood', struct: 'tb' },

      [k('ç”°','å¿ƒ')]: { char: 'æ€', power: 15, desc: 'æ€è€ƒ', type: 'mind', struct: 'tb' },
      [k('ç›¸','å¿ƒ')]: { char: 'æƒ³', power: 15, desc: 'æƒ³å¿µ', type: 'mind', struct: 'tb' },
      [k('ä»Š','å¿ƒ')]: { char: 'å¿µ', power: 15, desc: 'å¿µä¹¦', type: 'mind', struct: 'tb' },
      [k('äº¡','å¿ƒ')]: { char: 'å¿˜', power: 15, desc: 'å¿˜è®°', type: 'mind', struct: 'tb' },
      [k('éŸ³','å¿ƒ')]: { char: 'æ„', power: 15, desc: 'æ„æ€', type: 'mind', struct: 'tb' },
      [k('ä¸­','å¿ƒ')]: { char: 'å¿ ', power: 18, desc: 'å¿ è¯š', type: 'good', struct: 'tb' },
      [k('å‹¿','å¿ƒ')]: { char: 'å¿½', power: 12, desc: 'å¿½ç„¶', type: 'time', struct: 'tb' },
      [k('åˆ','å¿ƒ')]: { char: 'æ€¥', power: 15, desc: 'ç€æ€¥', type: 'action', struct: 'tb' },
      [k('è‡ª','å¿ƒ')]: { char: 'æ¯', power: 15, desc: 'ä¼‘æ¯', type: 'heal', struct: 'tb' },
      [k('å¥´','å¿ƒ')]: { char: 'æ€’', power: 20, desc: 'å‘æ€’', type: 'attack', struct: 'tb' },

      [k('å£','è´')]: { char: 'å‘˜', power: 12, desc: 'å‘˜å·¥', type: 'normal', struct: 'tb' },
      [k('åˆ†','è´')]: { char: 'è´«', power: 10, desc: 'è´«ç©·', type: 'normal', struct: 'tb' },
      [k('ä»Š','è´')]: { char: 'è´ª', power: 10, desc: 'è´ªå¿ƒ', type: 'normal', struct: 'tb' },
      [k('åŒ–','è´')]: { char: 'è´§', power: 15, desc: 'è´§ç‰©', type: 'gold', struct: 'tb' },
      [k('å·¥','è´')]: { char: 'è´¡', power: 15, desc: 'è´¡çŒ®', type: 'good', struct: 'tb' },
      [k('åŠ ','è´')]: { char: 'è´º', power: 15, desc: 'ç¥è´º', type: 'good', struct: 'tb' },
      [k('ä»£','è´')]: { char: 'è´·', power: 15, desc: 'è´·æ¬¾', type: 'gold', struct: 'tb' },
      [k('æ¬¡','è´')]: { char: 'èµ„', power: 15, desc: 'èµ„æº', type: 'gold', struct: 'tb' },
      [k('å°š','è´')]: { char: 'èµ', power: 18, desc: 'å¥–èµ', type: 'gold', struct: 'tb' },
      [k('è¥¿','è´')]: { char: 'è´¾', power: 12, desc: 'å•†è´¾', type: 'gold', struct: 'tb' },

      [k('é›¨','ç”°')]: { char: 'é›·', power: 25, desc: 'é›·ç”µ', type: 'attack', struct: 'tb' },
      [k('é›¨','åŠ¡')]: { char: 'é›¾', power: 15, desc: 'è¿·é›¾', type: 'water', struct: 'tb' },
      [k('é›¨','ç›¸')]: { char: 'éœœ', power: 18, desc: 'å†°éœœ', type: 'water', struct: 'tb' },
      [k('é›¨','ä»¤')]: { char: 'é›¶', power: 12, desc: 'é›¶åº¦', type: 'water', struct: 'tb' },
      [k('é›¨','åŒ…')]: { char: 'é›¹', power: 20, desc: 'å†°é›¹', type: 'attack', struct: 'tb' },

      [k('ç©´','å·¥')]: { char: 'ç©º', power: 15, desc: 'å¤©ç©º', type: 'air', struct: 'tb' },
      [k('ç©´','ç‰™')]: { char: 'ç©¿', power: 15, desc: 'ç©¿è¶Š', type: 'action', struct: 'tb' },
      [k('ç©´','åŠ›')]: { char: 'ç©·', power: 10, desc: 'è´«ç©·', type: 'normal', struct: 'tb' },
      [k('ç©´','ä¹')]: { char: 'ç©¶', power: 15, desc: 'ç ”ç©¶', type: 'mind', struct: 'tb' },
      [k('ç©´','çŠ¬')]: { char: 'çª', power: 18, desc: 'çªç„¶', type: 'action', struct: 'tb' },

      [k('åˆ†','çš¿')]: { char: 'ç›†', power: 12, desc: 'è„¸ç›†', type: 'normal', struct: 'tb' },
      [k('èˆŸ','çš¿')]: { char: 'ç›˜', power: 15, desc: 'ç›˜å­', type: 'normal', struct: 'tb' },
      [k('æˆ','çš¿')]: { char: 'ç››', power: 15, desc: 'ç››å¼€', type: 'wood', struct: 'tb' },
      [k('åˆ','çš¿')]: { char: 'ç›’', power: 12, desc: 'ç›’å­', type: 'normal', struct: 'tb' },
      [k('ç¾Š','çš¿')]: { char: 'ç›–', power: 15, desc: 'ç›–å­', type: 'defense', struct: 'tb' },

      [k('ç”°','åŠ›')]: { char: 'ç”·', power: 15, desc: 'ç”·äºº', type: 'normal', struct: 'tb' },
      [k('çˆ¶','å·´')]: { char: 'çˆ¸', power: 15, desc: 'çˆ¸çˆ¸', type: 'normal', struct: 'tb' },
      [k('å°','å¤§')]: { char: 'å°–', power: 15, desc: 'å°–é”', type: 'sharp', struct: 'tb' },
      [k('å°','åœŸ')]: { char: 'å°˜', power: 12, desc: 'å°˜åœŸ', type: 'earth', struct: 'tb' },
      [k('ä¸','æ­£')]: { char: 'æ­ª', power: 12, desc: 'æ­ªæ–œ', type: 'normal', struct: 'tb' },
      [k('å±±','çŸ³')]: { char: 'å²©', power: 18, desc: 'å²©çŸ³', type: 'earth', struct: 'tb' },
      [k('æ—¥','ç”Ÿ')]: { char: 'æ˜Ÿ', power: 20, desc: 'æ˜Ÿæ˜Ÿ', type: 'light', struct: 'tb' },
      [k('æ—¥','å')]: { char: 'æ—©', power: 12, desc: 'æ—©æ™¨', type: 'time', struct: 'tb' },
      [k('æ—¥','ä¸€')]: { char: 'æ—¦', power: 15, desc: 'å…ƒæ—¦', type: 'time', struct: 'tb' },
      [k('ç™½','ç‹')]: { char: 'çš‡', power: 25, desc: 'çš‡å¸', type: 'epic', struct: 'tb' },
      [k('ç™½','æ°´')]: { char: 'æ³‰', power: 15, desc: 'æ³‰æ°´', type: 'water', struct: 'tb' },
      [k('ç¦¾','æ—¥')]: { char: 'é¦™', power: 15, desc: 'é¦™æ°”', type: 'good', struct: 'tb' },
      [k('ç¦¾','å­')]: { char: 'å­£', power: 15, desc: 'å­£èŠ‚', type: 'time', struct: 'tb' },
      [k('ç¦¾','å¥³')]: { char: 'å§”', power: 12, desc: 'å§”æ‰˜', type: 'normal', struct: 'tb' },
      [k('æœ¨','å£')]: { char: 'æ', power: 12, desc: 'æå­', type: 'wood', struct: 'tb' },
      [k('å£','æœ¨')]: { char: 'å‘†', power: 10, desc: 'å‘å‘†', type: 'mind', struct: 'tb' },
      [k('æœ¨','å­')]: { char: 'æ', power: 12, desc: 'æå­', type: 'wood', struct: 'tb' },
      [k('åˆ©','æœ¨')]: { char: 'æ¢¨', power: 12, desc: 'æ¢¨å­', type: 'wood', struct: 'tb' },
      [k('ç”˜','æœ¨')]: { char: 'æŸ', power: 10, desc: 'æŸäºº', type: 'normal', struct: 'tb' },
      [k('å‡ ','æœ¨')]: { char: 'æœµ', power: 12, desc: 'èŠ±æœµ', type: 'wood', struct: 'tb' },
      [k('æ­¢','æœˆ')]: { char: 'è‚¯', power: 12, desc: 'è‚¯å®š', type: 'mind', struct: 'tb' },
      [k('å°','æœˆ')]: { char: 'è‚–', power: 12, desc: 'è‚–åƒ', type: 'normal', struct: 'tb' },
      [k('äº‘','æœˆ')]: { char: 'è‚²', power: 15, desc: 'æ•™è‚²', type: 'mind', struct: 'tb' },
      [k('ç”°','æœˆ')]: { char: 'èƒƒ', power: 15, desc: 'è‚ èƒƒ', type: 'body', struct: 'tb' },
      [k('ç«‹','æ—¥')]: { char: 'éŸ³', power: 15, desc: 'éŸ³ä¹', type: 'sound', struct: 'tb' },

      // === åŒ…å›´/åŠåŒ…å›´ç»“æ„ (sur) ===
      [k('å›—','ç‰')]: { char: 'å›½', power: 20, desc: 'å›½å®¶', type: 'epic', struct: 'sur' },
      [k('å›—','æ‰')]: { char: 'å›¢', power: 15, desc: 'å›¢ç»“', type: 'good', struct: 'sur' },
      [k('å›—','å…ƒ')]: { char: 'å›­', power: 15, desc: 'èŠ±å›­', type: 'wood', struct: 'sur' },
      [k('å›—','å¤§')]: { char: 'å› ', power: 12, desc: 'å› ä¸º', type: 'mind', struct: 'sur' },
      [k('å›—','å¤')]: { char: 'å›º', power: 18, desc: 'åšå›º', type: 'defense', struct: 'sur' },
      [k('å›—','æœ¨')]: { char: 'å›°', power: 10, desc: 'å›°éš¾', type: 'mind', struct: 'sur' },
      [k('å›—','äºº')]: { char: 'å›š', power: 12, desc: 'å›šçŠ¯', type: 'normal', struct: 'sur' },
      [k('å›—','å£')]: { char: 'å›', power: 15, desc: 'å›å®¶', type: 'action', struct: 'sur' },
      [k('å›—','éŸ¦')]: { char: 'å›´', power: 15, desc: 'åŒ…å›´', type: 'defense', struct: 'sur' },
      [k('å›—','å†¬')]: { char: 'å›¾', power: 15, desc: 'å›¾ä¹¦', type: 'mind', struct: 'sur' },
      [k('å›—','å·')]: { char: 'åœˆ', power: 15, desc: 'åœ†åœˆ', type: 'normal', struct: 'sur' },
      [k('å›—','å‘˜')]: { char: 'åœ†', power: 15, desc: 'åœ†å½¢', type: 'normal', struct: 'sur' },
      [k('å›—','ä»¤')]: { char: 'å›¹', power: 12, desc: 'å›¹åœ„', type: 'normal', struct: 'sur' },
      [k('å›—','ç”«')]: { char: 'åœƒ', power: 15, desc: 'è‹—åœƒ', type: 'wood', struct: 'sur' },
      [k('å›—','å±¯')]: { char: 'å›¤', power: 15, desc: 'å›¤ç§¯', type: 'gold', struct: 'sur' },

      [k('è¾¶','äº•')]: { char: 'è¿›', power: 15, desc: 'å‰è¿›', type: 'action', struct: 'sur' },
      [k('è¾¶','å¯¸')]: { char: 'è¿‡', power: 12, desc: 'è¿‡å»', type: 'time', struct: 'sur' },
      [k('è¾¶','æ–¤')]: { char: 'è¿‘', power: 12, desc: 'é è¿‘', type: 'normal', struct: 'sur' },
      [k('è¾¶','å…ƒ')]: { char: 'è¿œ', power: 15, desc: 'é¥è¿œ', type: 'normal', struct: 'sur' },
      [k('è¾¶','åŠ›')]: { char: 'è¾¹', power: 12, desc: 'æ—è¾¹', type: 'normal', struct: 'sur' },
      [k('è¾¶','åƒ')]: { char: 'è¿', power: 15, desc: 'è¿ç§»', type: 'action', struct: 'sur' },
      [k('è¾¶','æ–‡')]: { char: 'è¿™', power: 10, desc: 'è¿™é‡Œ', type: 'normal', struct: 'sur' },
      [k('è¾¶','ä¸')]: { char: 'è¿˜', power: 12, desc: 'å½’è¿˜', type: 'normal', struct: 'sur' },
      [k('è¾¶','è½¦')]: { char: 'è¿', power: 15, desc: 'è¿æ¥', type: 'normal', struct: 'sur' },
      [k('è¾¶','äº‘')]: { char: 'è¿', power: 15, desc: 'è¿åŠ¨', type: 'action', struct: 'sur' },
      [k('è¾¶','ç™½')]: { char: 'è¿«', power: 15, desc: 'è¿«åˆ‡', type: 'time', struct: 'sur' },
      [k('è¾¶','å‘Š')]: { char: 'é€ ', power: 18, desc: 'åˆ›é€ ', type: 'epic', struct: 'sur' },
      [k('è¾¶','å…†')]: { char: 'é€ƒ', power: 15, desc: 'é€ƒè·‘', type: 'action', struct: 'sur' },
      [k('è¾¶','ç±³')]: { char: 'è¿·', power: 12, desc: 'è¿·è·¯', type: 'mind', struct: 'sur' },
      [k('è¾¶','å…³')]: { char: 'é€', power: 15, desc: 'èµ é€', type: 'good', struct: 'sur' },
      [k('è¾¶','é¦–')]: { char: 'é“', power: 18, desc: 'é“è·¯', type: 'earth', struct: 'sur' },
      [k('è¾¶','å…ˆ')]: { char: 'é€‰', power: 15, desc: 'é€‰æ‹©', type: 'mind', struct: 'sur' },
      [k('è¾¶','èˆŒ')]: { char: 'é€‚', power: 15, desc: 'åˆé€‚', type: 'good', struct: 'sur' },
      [k('è¾¶','äº¦')]: { char: 'è¿¹', power: 15, desc: 'ç—•è¿¹', type: 'normal', struct: 'sur' },
      [k('è¾¶','å·›')]: { char: 'å·¡', power: 15, desc: 'å·¡é€»', type: 'action', struct: 'sur' },

      [k('é—¨','å£')]: { char: 'é—®', power: 12, desc: 'é—®é¢˜', type: 'mind', struct: 'sur' },
      [k('é—¨','æ—¥')]: { char: 'é—´', power: 12, desc: 'æ—¶é—´', type: 'time', struct: 'sur' },
      [k('é—¨','äºº')]: { char: 'é—ª', power: 18, desc: 'é—ªç”µ', type: 'light', struct: 'sur' },
      [k('é—¨','æœ¨')]: { char: 'é—²', power: 12, desc: 'ç©ºé—²', type: 'time', struct: 'sur' },
      [k('é—¨','è€³')]: { char: 'é—»', power: 15, desc: 'æ–°é—»', type: 'mind', struct: 'sur' },
      [k('é—¨','å¸‚')]: { char: 'é—¹', power: 15, desc: 'çƒ­é—¹', type: 'sound', struct: 'sur' },
      [k('é—¨','æ‰')]: { char: 'é—­', power: 15, desc: 'å…³é—­', type: 'defense', struct: 'sur' },
      [k('é—¨','æ´»')]: { char: 'é˜”', power: 18, desc: 'å¹¿é˜”', type: 'earth', struct: 'sur' },
      [k('é—¨','å…‘')]: { char: 'é˜…', power: 15, desc: 'é˜…è¯»', type: 'mind', struct: 'sur' },
      [k('é—¨','é©¬')]: { char: 'é—¯', power: 20, desc: 'é—¯è¡', type: 'attack', struct: 'sur' },
      [k('é—¨','å¿ƒ')]: { char: 'é—·', power: 12, desc: 'éƒé—·', type: 'mind', struct: 'sur' },
      [k('é—¨','åœ­')]: { char: 'é—º', power: 15, desc: 'é—ºèœœ', type: 'normal', struct: 'sur' },
      [k('å¿ƒ','äºš')]: { char: 'æ¶', power: 20, desc: 'å‡¶æ¶', type: 'attack', struct: 'sur' }, 
      [k('é—¨','è™«')]: { char: 'é—½', power: 15, desc: 'ç¦å»º', type: 'earth', struct: 'sur' },
      [k('é—¨','ä¸€')]: { char: 'é—©', power: 15, desc: 'é—¨é—©', type: 'defense', struct: 'sur' },
      [k('é—¨','éŸ¦')]: { char: 'é—±', power: 12, desc: 'ç§‘ä¸¾', type: 'mind', struct: 'sur' },

      [k('å¹¿','æœ¨')]: { char: 'åºŠ', power: 15, desc: 'èµ·åºŠ', type: 'heal', struct: 'sur' },
      [k('å¹¿','å ')]: { char: 'åº—', power: 15, desc: 'å•†åº—', type: 'gold', struct: 'sur' },
      [k('å¹¿','ä»˜')]: { char: 'åºœ', power: 18, desc: 'åºœé‚¸', type: 'defense', struct: 'sur' },
      [k('å¹¿','å')]: { char: 'åº§', power: 15, desc: 'åº§ä½', type: 'normal', struct: 'sur' },
      [k('å¹¿','è½¦')]: { char: 'åº“', power: 18, desc: 'ä»“åº“', type: 'gold', struct: 'sur' },
      [k('å¹¿','æ—')]: { char: 'éº»', power: 15, desc: 'éº»çƒ¦', type: 'normal', struct: 'sur' },
      [k('å¹¿','äºˆ')]: { char: 'åº', power: 15, desc: 'é¡ºåº', type: 'normal', struct: 'sur' },
      [k('å¹¿','å¤§')]: { char: 'åº†', power: 18, desc: 'åº†ç¥', type: 'good', struct: 'sur' },
      [k('å¹¿','åœŸ')]: { char: 'åº„', power: 15, desc: 'åº„ä¸¥', type: 'earth', struct: 'sur' },
      [k('å¹¿','å»·')]: { char: 'åº­', power: 15, desc: 'å®¶åº­', type: 'defense', struct: 'sur' },
      [k('å¹¿','éš¶')]: { char: 'åº·', power: 18, desc: 'å¥åº·', type: 'heal', struct: 'sur' },
      [k('å¹¿','å‘')]: { char: 'åºŸ', power: 10, desc: 'åºŸå¼ƒ', type: 'normal', struct: 'sur' },
      [k('å¹¿','éƒ')]: { char: 'å»Š', power: 15, desc: 'èµ°å»Š', type: 'normal', struct: 'sur' },
      [k('å¹¿','å¾')]: { char: 'åº¸', power: 10, desc: 'å¹³åº¸', type: 'normal', struct: 'sur' },

      [k('ç–’','ä¸™')]: { char: 'ç—…', power: 10, desc: 'ç”Ÿç—…', type: 'normal', struct: 'sur' },
      [k('ç–’','ç”¬')]: { char: 'ç—›', power: 15, desc: 'ç—›è‹¦', type: 'attack', struct: 'sur' },
      [k('ç–’','æ­£')]: { char: 'ç—‡', power: 12, desc: 'ç—‡çŠ¶', type: 'normal', struct: 'sur' },
      [k('ç–’','é£')]: { char: 'ç–¯', power: 18, desc: 'ç–¯ç‹‚', type: 'attack', struct: 'sur' },
      [k('ç–’','ç¾Š')]: { char: 'ç—’', power: 10, desc: 'ç˜™ç—’', type: 'normal', struct: 'sur' },
      [k('ç–’','è‰®')]: { char: 'ç—•', power: 12, desc: 'ç—•è¿¹', type: 'normal', struct: 'sur' },
      [k('ç–’','å†¬')]: { char: 'ç–¼', power: 15, desc: 'ç–¼ç—›', type: 'attack', struct: 'sur' },
      [k('ç–’','çŸ¥')]: { char: 'ç—´', power: 12, desc: 'ç—´è¿·', type: 'mind', struct: 'sur' },
      [k('ç–’','çš®')]: { char: 'ç–²', power: 10, desc: 'ç–²åŠ³', type: 'normal', struct: 'sur' },

      [k('å°¸','å¤')]: { char: 'å±…', power: 15, desc: 'å±…ä½', type: 'earth', struct: 'sur' },
      [k('å°¸','å‡º')]: { char: 'å±ˆ', power: 15, desc: 'å§”å±ˆ', type: 'mind', struct: 'sur' },
      [k('å°¸','æ¯›')]: { char: 'å°¾', power: 12, desc: 'å°¾å·´', type: 'body', struct: 'sur' },
      [k('å°¸','è‡³')]: { char: 'å±‹', power: 15, desc: 'æˆ¿å±‹', type: 'defense', struct: 'sur' },
      [k('å°¸','æ°´')]: { char: 'å°¿', power: 10, desc: '...', type: 'water', struct: 'sur' },
      [k('å°¸','äº‘')]: { char: 'å±‚', power: 15, desc: 'æ¥¼å±‚', type: 'earth', struct: 'sur' },
      [k('å°¸','ç”±')]: { char: 'å±Š', power: 12, desc: 'å±Šæ—¶', type: 'time', struct: 'sur' },
      [k('å°¸','ç±³')]: { char: 'å±', power: 10, desc: '...', type: 'earth', struct: 'sur' },
      [k('å°¸','è‚–')]: { char: 'å±‘', power: 10, desc: 'çº¸å±‘', type: 'normal', struct: 'sur' },

      [k('èµ°','å·±')]: { char: 'èµ·', power: 15, desc: 'èµ·åºŠ', type: 'action', struct: 'sur' },
      [k('èµ°','å¹²')]: { char: 'èµ¶', power: 15, desc: 'èµ¶è·¯', type: 'action', struct: 'sur' },
      [k('èµ°','å¬')]: { char: 'è¶…', power: 18, desc: 'è¶…çº§', type: 'epic', struct: 'sur' },
      [k('èµ°','å–')]: { char: 'è¶£', power: 15, desc: 'æœ‰è¶£', type: 'good', struct: 'sur' },
      [k('èµ°','è‚–')]: { char: 'èµµ', power: 15, desc: 'èµµå›½', type: 'normal', struct: 'sur' },
      [k('èµ°','æˆ‰')]: { char: 'è¶Š', power: 18, desc: 'è¶…è¶Š', type: 'action', struct: 'sur' },
      [k('èµ°','å°š')]: { char: 'è¶Ÿ', power: 12, desc: 'ä¸€è¶Ÿ', type: 'action', struct: 'sur' },

      [k('å‹¹','å·³')]: { char: 'åŒ…', power: 15, desc: 'ä¹¦åŒ…', type: 'normal', struct: 'sur' },
      [k('å‹¹','å£')]: { char: 'å¥', power: 12, desc: 'å¥å­', type: 'mind', struct: 'sur' },
      [k('å‹¹','ä¸€')]: { char: 'å‹º', power: 12, desc: 'å‹ºå­', type: 'normal', struct: 'sur' },
      [k('å‡ ','ä¹‚')]: { char: 'é£', power: 15, desc: 'å¤§é£', type: 'air', struct: 'sur' },
      [k('å‡ ','åˆ')]: { char: 'å‡¤', power: 20, desc: 'å‡¤å‡°', type: 'epic', struct: 'sur' },
      [k('åŒš','çŸ¢')]: { char: 'åŒ»', power: 18, desc: 'åŒ»ç”Ÿ', type: 'heal', struct: 'sur' },
      [k('åŒš','ä¹‚')]: { char: 'åŒº', power: 15, desc: 'åŒºåŸŸ', type: 'earth', struct: 'sur' },
      [k('åŒš','å„¿')]: { char: 'åŒ¹', power: 12, desc: 'åŒ¹é…', type: 'normal', struct: 'sur' },

      // === ä¸‰å­—ç»„åˆ (å²è¯—ç»“æ„) ===
      [k('åˆ','å¥³','å¿ƒ')]: { char: 'æ€’', power: 35, desc: 'æ„¤æ€’', type: 'epic', struct: 'tb' },
      [k('æœ¨','æœ¨','æœ¨')]: { char: 'æ£®', power: 35, desc: 'æ£®æ—', type: 'epic', struct: 'tri' },
      [k('å£','å£','å£')]: { char: 'å“', power: 30, desc: 'å“è´¨', type: 'epic', struct: 'tri' },
      [k('ç«','ç«','ç«')]: { char: 'ç„±', power: 45, desc: 'çƒˆç„°', type: 'epic', struct: 'tri' },
      [k('åœŸ','åœŸ','åœŸ')]: { char: 'åš', power: 40, desc: 'é«˜è€¸', type: 'epic', struct: 'tri' },
      [k('åˆ','åˆ','åˆ')]: { char: 'å’', power: 35, desc: 'åŒå¿ƒ', type: 'epic', struct: 'tri' },
      [k('å¿ƒ','ç›¸')]: { char: 'æƒ³', power: 30, desc: 'æ¢¦æƒ³', type: 'epic', struct: 'tb' },
    };

    // æå–æ‰€æœ‰ç”¨åˆ°çš„éƒ¨ä»¶
    const RADICAL_DECK = [
      // åŸºç¡€
      'æ°µ', 'äº»', 'è® ', 'æœ¨', 'å£', 'å¥³', 'åœŸ', 'æ‰Œ', 
      // ç»“æ„éƒ¨ä»¶
      'è‰¹', 'å®€', 'âº®', 'å¿ƒ', 'è´', 'é›¨', 'ç©´', 'çš¿', 'å›—', 'è¾¶', 'é—¨', 'å¹¿', 'ç–’', 'å°¸', 'èµ°', 'å‹¹',
      // å¸¸ç”¨ç‹¬ä½“å­—
      'å·¥', 'å¯', 'èƒ¡', 'æ¯', 'ç¾Š', 'å¹²', 'ç›®', 'å…ˆ', 'æ°”', 'æ°¸', 'å°‘', 'èˆŒ', 'å»', 'ç‚', 'ä¸»',
      'å°”', 'ä¹Ÿ', 'å', 'æ•…', 'ä¹', 'è¨€', 'æ—¦', 'éŸ¦', 'å‘†', 'æ‰', 'è±¡', 'äº­', 'å°¤', 'å',
      'ä¸', 'åŒ…', 'å·´', 'çˆª', 'æˆ·', 'æ—¨', 'å¯º', 'åœ­', 'å“', 'åœ', 'ä¹ƒ', 'éš¹', 'å¦¾',
      'äºº', 'ä¸Š', 'åª', 'ä¹‰', 'å·±', 'äº•', 'åˆ', 'å…‘', 'å–', 'å¾', 'å°„', 'é’', 'æœ',
      'å¯¸', 'æ‰', 'å', 'åŠ', 'æ”¯', 'ä¸', 'é£', 'å‡ ', 'äº¤', 'å¯', 'å¯¹', 'æ˜†', 'å¸›', 'è‰®', 'æ—',
      'æ˜Œ', 'ä¹', 'æ–¤', 'æ¬ ', 'å°¼', 'é‚£', 'ç‰™', 'æœª', 'äº¢',
      'å­', 'é©¬', 'ä¸”', 'å¤', 'ä¹”', 'èƒ¥', 'é¬¼', 'çš®', 'ç”³',
      'åŒ–', 'æ—©', 'é‡‡', 'ç”°', 'å¹³', 'ä½™', 'æ±¤', 'å®£', 'å¤®', 'åˆ†', 'æ–¹', 'èŠ‚', 'ä¹™',
      'ç‰', 'è±•', 'å…ƒ', 'è°·', 'å„', 'å®…', 'è§', 'å¥‡', 'å•',
      'æ¯›', 'å®˜', 'åˆ', 'æœ¬', 'å¤­', 'åŒ¡', 'é—´', 'æ—¬',
      'ç›¸', 'ä»Š', 'äº¡', 'éŸ³', 'ä¸­', 'å‹¿', 'åˆ', 'è‡ª', 'å¥´',
      'åŒ–', 'åŠ ', 'ä»£', 'æ¬¡', 'å°š', 'è¥¿',
      'åŠ¡', 'ä»¤', 'ä¹', 'çŠ¬', 'èˆŸ', 'æˆ', 'ç«‹', 'çˆ¶', 'å°', 'å¤§', 'å±±', 'çŸ³', 'æ—¥', 'ç”Ÿ', 'ä¸€', 'ç™½', 'æ°´', 'ç¦¾', 'åˆ©', 'ç”˜', 'æ­¢', 'äº‘',
      'å·', 'å‘˜', 'ç”«', 'å±¯',
      'åƒ', 'æ–‡', 'è½¦', 'å‘Š', 'å…†', 'ç±³', 'å…³', 'é¦–', 'é€‰', 'äº¦', 'å·›',
      'è€³', 'å¸‚', 'æ´»', 'è™«',
      'å ', 'ä»˜', 'å', 'äºˆ', 'å»·', 'éš¶', 'å‘', 'éƒ',
      'ä¸™', 'ç”¬', 'æ­£', 'çŸ¥',
      'å‡º', 'è‡³', 'ç”±', 'è‚–',
      'èµ·', 'å¬', 'å–', 'æˆ‰',
      'å·³', 'çŸ¢', 'å„¿', 'å¸Œ'
    ];

    const MAX_HINTS = 5;

    // --- 2. éŸ³æ•ˆæ§åˆ¶ (Web Audio API) ---
    let audioCtx = null;
    const initAudio = () => {
      if (!audioCtx) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (AudioContext) audioCtx = new AudioContext();
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    };

    const playSound = (type) => {
      if (!audioCtx) initAudio();
      if (!audioCtx) return;

      const osc = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      
      if (type === 'select') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
      } else if (type === 'attack_normal') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.2);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
      } else if (type === 'attack_rare') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.2);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
      } else if (type === 'attack_epic') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.5);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
      } else if (type === 'crit') { 
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.1);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
      } else if (type === 'win') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.setValueAtTime(554, now + 0.1);
        osc.frequency.setValueAtTime(659, now + 0.2);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
      } else if (type === 'hit') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.2);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
      } else if (type === 'block') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.2);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
      } else if (type === 'heal') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.3);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
      }
    };

    // --- 3. è¾…åŠ©ç»„ä»¶ ---
    const StructureIcon = ({ type, size=16 }) => {
      const style = { width: size, height: size };
      switch(type) {
        case 'lr': return <MoveRight style={style} className="text-stone-400" title="å·¦å³ç»“æ„" />;
        case 'tb': return <Layers style={style} className="text-stone-400" title="ä¸Šä¸‹ç»“æ„" />;
        case 'sur': return <Box style={style} className="text-stone-400" title="åŒ…å›´ç»“æ„" />;
        case 'tri': return <span className="text-[10px] font-bold text-amber-500">å“</span>;
        default: return null;
      }
    };

    const Card = ({ char, selected, onClick, disabled, isHinted }) => (
      <button
        onClick={() => {
          if (!disabled) {
            playSound('select');
            onClick(char);
          }
        }}
        className={`
          relative w-12 h-16 sm:w-14 sm:h-20 md:w-16 md:h-24 rounded-lg border-2 shadow-md transition-all duration-200 flex items-center justify-center text-2xl md:text-3xl font-serif select-none touch-manipulation
          ${selected 
            ? 'bg-amber-100 border-amber-600 -translate-y-3 shadow-amber-500/50 z-10' 
            : isHinted 
              ? 'bg-yellow-50 border-yellow-400 ring-2 ring-yellow-400 ring-offset-1 animate-pulse'
              : 'bg-stone-50 border-stone-300 active:scale-95 hover:-translate-y-1 hover:border-stone-400 text-stone-800'}
          ${disabled ? 'opacity-50 cursor-not-allowed grayscale' : 'cursor-pointer'}
        `}
      >
        <div className="absolute top-0.5 left-1 text-[8px] text-stone-400">éƒ¨é¦–</div>
        {char}
      </button>
    );

    const getRarity = (type) => {
      if (type === 'epic') return 'epic';
      if (type === 'normal') return 'normal';
      return 'rare';
    };

    const getRarityConfig = (rarity) => {
      switch (rarity) {
        case 'epic': return { color: 'text-amber-600', border: 'border-amber-500', bg: 'bg-amber-50', label: 'å²è¯—', icon: <Star fill="currentColor" size={12}/> };
        case 'rare': return { color: 'text-indigo-600', border: 'border-indigo-400', bg: 'bg-indigo-50', label: 'ç¨€æœ‰', icon: <Sparkles size={12}/> };
        default: return { color: 'text-stone-600', border: 'border-stone-300', bg: 'bg-stone-50', label: 'æ™®é€š', icon: null };
      }
    };

    const Monster = ({ level, hp, maxHp, isAttacking, onHitAnim, turn, monsterType }) => (
      <div className="flex flex-col items-center justify-center relative w-full">
        <div className="w-3/4 max-w-xs h-3 md:h-4 bg-stone-800 rounded-full mb-4 overflow-hidden border border-stone-600 relative">
          <div 
            className="h-full bg-red-600 transition-all duration-300"
            style={{ width: `${(hp / maxHp) * 100}%` }}
          />
        </div>
        <div className={`
          w-28 h-28 md:w-48 md:h-48 bg-stone-800 rounded-2xl flex items-center justify-center text-6xl md:text-8xl shadow-2xl border-4 transition-transform duration-300 relative
          ${isAttacking ? 'translate-y-12 scale-110 z-20 shadow-red-500/50' : ''}
          ${onHitAnim ? 'shake-animation bg-red-900' : ''}
          ${turn === 'enemy' ? 'border-red-500 shadow-red-500/50 scale-105' : 'border-stone-600'}
        `}>
          <span className="filter drop-shadow-lg animate-bounce-slow">
            {monsterType.icon}
          </span>
          {turn === 'enemy' && (
            <div className="absolute -top-10 text-red-600 font-bold animate-pulse text-lg">è“„åŠ›ä¸­...</div>
          )}
          <div className="absolute -right-4 bottom-0 bg-white border border-stone-300 px-2 py-1 rounded text-[10px] text-stone-500 shadow">
            å¼±ç‚¹: {monsterType.weakness === 'none' ? 'æ— ' : 
                   monsterType.weakness === 'water' ? 'æ°µ' :
                   monsterType.weakness === 'earth' ? 'åœŸ' :
                   monsterType.weakness === 'mind' ? 'å¿ƒ' : 'æ— '}
          </div>
        </div>
        <div className="mt-4 text-center bg-white/80 px-4 py-2 rounded-lg shadow-sm backdrop-blur-sm">
          <div className="font-bold text-stone-700 text-lg flex items-center justify-center gap-2">
            <span>Lv.{level} {monsterType.name}</span>
          </div>
          <div className="text-xs text-stone-500 mt-1">{monsterType.desc}</div>
          <div className="text-xs font-mono text-stone-400 mt-1">HP: {hp}/{maxHp}</div>
        </div>
      </div>
    );

    const FloatingText = ({ text, type, rarity }) => {
      let colorClass = 'text-green-600';
      let sizeClass = 'text-2xl';
      let shadowClass = '';
      if (type === 'damage') {
        if (rarity === 'crit') {
          colorClass = 'text-purple-600';
          sizeClass = 'text-5xl md:text-7xl';
          shadowClass = 'drop-shadow-[0_0_10px_rgba(147,51,234,0.5)]';
        } else if (rarity === 'epic') {
          colorClass = 'text-amber-500';
          sizeClass = 'text-5xl md:text-7xl';
          shadowClass = 'drop-shadow-[0_4px_4px_rgba(0,0,0,0.5)]';
        } else if (rarity === 'rare') {
          colorClass = 'text-indigo-600';
          sizeClass = 'text-4xl md:text-6xl';
          shadowClass = 'drop-shadow-md';
        } else {
          colorClass = 'text-red-600';
          sizeClass = 'text-3xl md:text-5xl';
        }
      } else if (type === 'heal') {
        colorClass = 'text-green-500';
        sizeClass = 'text-3xl md:text-5xl';
      } else if (type === 'block') {
        colorClass = 'text-stone-500';
        sizeClass = 'text-2xl';
      } else if (type === 'info') {
        colorClass = 'text-blue-600';
        sizeClass = 'text-xl';
      }
      return (
        <div className={`absolute z-50 font-bold animate-float-up pointer-events-none whitespace-nowrap ${colorClass} ${sizeClass} ${shadowClass}`} style={{ top: '40%', left: '50%', transform: 'translate(-50%, -50%)' }}>
          {text}
        </div>
      );
    };

    // --- 4. æ¸¸æˆä¸»é€»è¾‘ ---

    function HanziMagicBattle() {
      const [scene, setScene] = useState('menu'); 
      const [character, setCharacter] = useState(CHARACTERS[0]);
      const [playerHp, setPlayerHp] = useState(100);
      const [maxPlayerHp, setMaxPlayerHp] = useState(100);
      const [mp, setMp] = useState(3); 
      const [hand, setHand] = useState([]);
      const [selectedIndices, setSelectedIndices] = useState([]);
      const [level, setLevel] = useState(1);
      const [monsterHp, setMonsterHp] = useState(50);
      const [maxMonsterHp, setMaxMonsterHp] = useState(50);
      const [currentMonster, setCurrentMonster] = useState(MONSTER_TYPES[0]);
      const [shield, setShield] = useState(0); 
      
      const [turn, setTurn] = useState('player'); 
      const [gameStatus, setGameStatus] = useState('playing'); 
      const [comboResult, setComboResult] = useState(null);
      const [hintIndices, setHintIndices] = useState([]);
      const [hintsLeft, setHintsLeft] = useState(3);
      
      const [floatingTexts, setFloatingTexts] = useState([]);
      const [monsterHit, setMonsterHit] = useState(false);
      const [monsterAttacking, setMonsterAttacking] = useState(false);
      const [soundEnabled, setSoundEnabled] = useState(true);

      const [discoveredWords, setDiscoveredWords] = useState([]);
      const [highScore, setHighScore] = useState(0);
      
      const [battleLogs, setBattleLogs] = useState([]);
      const [showLogs, setShowLogs] = useState(false);
      const [showDictionary, setShowDictionary] = useState(false);

      const idCounter = useRef(0);
      const getUniqueId = () => {
        idCounter.current += 1;
        return `${Date.now()}_${idCounter.current}`;
      };

      const addLog = (text, type = 'info') => {
        const time = new Date().toLocaleTimeString([], { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
        setBattleLogs(prev => [...prev, { id: getUniqueId(), text, type, time }]);
      };
      
      // æ—¥å¿—ç»„ä»¶
      const BattleLogModal = ({ logs, onClose }) => {
        const scrollRef = useRef(null);
        useEffect(() => {
          if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
        }, [logs]);
        return (
          <div className="fixed inset-0 bg-stone-900/50 z-[70] flex items-center justify-center p-4">
            <div className="bg-white w-full max-w-md h-[60vh] rounded-xl shadow-2xl flex flex-col overflow-hidden animate-fade-in">
              <div className="p-3 bg-stone-100 border-b flex justify-between items-center">
                <h3 className="font-bold flex items-center gap-2"><FileText size={18}/> æˆ˜æ–—è®°å½•</h3>
                <button onClick={onClose}><X size={20}/></button>
              </div>
              <div ref={scrollRef} className="flex-1 overflow-y-auto p-4 space-y-2 bg-stone-50 font-mono text-sm">
                {logs.length === 0 && <div className="text-stone-400 text-center italic mt-10">æˆ˜æ–—æ‰åˆšåˆšå¼€å§‹...</div>}
                {logs.map(log => (
                  <div key={log.id} className={`p-2 rounded border-l-2 ${
                    log.type === 'player' ? 'border-blue-500 bg-blue-50' : 
                    log.type === 'enemy' ? 'border-red-500 bg-red-50' : 
                    'border-stone-400 bg-stone-100'
                  }`}>
                    <span className="text-xs text-stone-400 mr-2">{log.time}</span>
                    {log.text}
                  </div>
                ))}
              </div>
            </div>
          </div>
        );
      };

      const findFirstValidCombo = (cards) => {
        const cardChars = cards.map(c => c.char);
        for (let i = 0; i < cardChars.length; i++) {
          for (let j = i + 1; j < cardChars.length; j++) {
            const key = [cardChars[i], cardChars[j]].sort().join('');
            if (COMBINATION_DB[key]) return [i, j];
          }
        }
        for (let i = 0; i < cardChars.length; i++) {
          for (let j = i + 1; j < cardChars.length; j++) {
            for (let k = j + 1; k < cardChars.length; k++) {
              const key = [cardChars[i], cardChars[j], cardChars[k]].sort().join('');
              if (COMBINATION_DB[key]) return [i, j, k];
            }
          }
        }
        return null;
      };

      // æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ç»„åˆæ•°é‡
      const countValidCombos = (cards) => {
        let count = 0;
        const cardChars = cards.map(c => c.char);
        // ç®€å•èµ·è§ï¼Œåªæ£€æŸ¥ä¸¤å­—ç»„åˆ
        for (let i = 0; i < cardChars.length; i++) {
          for (let j = i + 1; j < cardChars.length; j++) {
            const key = [cardChars[i], cardChars[j]].sort().join('');
            if (COMBINATION_DB[key]) count++;
          }
        }
        return count;
      };

      // æŠ½ç‰Œæ ¸å¿ƒé€»è¾‘ (ä¿®å¤ï¼šä¿è¯è‡³å°‘3ä¸ªç»„åˆ)
      const drawCards = useCallback((currentHand, count) => {
        let attempts = 0;
        let bestHand = [];
        let maxCombos = -1;

        // å°è¯•å¤šæ¬¡ç”Ÿæˆæ‰‹ç‰Œï¼Œå–æœ€å¥½çš„ç»“æœ
        while (attempts < 20) {
           let newCards = [];
           for (let i = 0; i < count; i++) {
             const randomIndex = Math.floor(Math.random() * RADICAL_DECK.length);
             newCards.push({
               id: Math.random().toString(36).substr(2, 9),
               char: RADICAL_DECK[randomIndex]
             });
           }
           
           const potentialHand = [...currentHand, ...newCards];
           const comboCount = countValidCombos(potentialHand);
           
           if (comboCount >= 3) {
             return newCards; // æ»¡è¶³æ¡ä»¶ï¼Œç›´æ¥è¿”å›
           }
           
           if (comboCount > maxCombos) {
             maxCombos = comboCount;
             bestHand = newCards;
           }
           attempts++;
        }

        // å¦‚æœéšæœºå¤šæ¬¡éƒ½ä¸è¡Œï¼Œå¼ºåˆ¶æ’å…¥ä¿åº•ç‰Œ
        let finalHand = [...bestHand];
        
        // éœ€è¦è¡¥å……çš„ç»„åˆæ•°
        let needed = 3 - maxCombos;
        if (needed > 0) {
           const keys = Object.keys(COMBINATION_DB);
           // è¿‡æ»¤å‡º2å­—ç»„åˆ
           const validKeys = keys.filter(k => k.length <= 2);
           
           for (let n = 0; n < needed; n++) {
              if (finalHand.length < 2) break; // ç©ºé—´ä¸è¶³
              
              const randomKey = validKeys[Math.floor(Math.random() * validKeys.length)];
              const guaranteedChars = randomKey.split('');
              
              // æ›¿æ¢æœ€åä¸¤å¼  (ç¡®ä¿ä¸è¶Šç•Œ)
              if (finalHand.length >= 2 + (n * 2)) {
                 // ä½¿ç”¨ unshift æˆ– push å¯èƒ½ä¼šç ´å React åˆ—è¡¨ key çš„ç¨³å®šæ€§ï¼Œç›´æ¥ä¿®æ”¹å±æ€§
                 // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ç¡®ä¿ç´¢å¼•æ˜¯æœ‰æ•ˆçš„
                 let idx1 = finalHand.length - 1 - (n*2);
                 let idx2 = finalHand.length - 2 - (n*2);
                 if (idx1 >= 0 && idx2 >= 0) {
                     finalHand[idx1].char = guaranteedChars[0];
                     finalHand[idx2].char = guaranteedChars[1];
                 }
              }
           }
        }
        
        return finalHand;
      }, []);

      // æ€ªç‰©å›åˆ
      useEffect(() => {
        if (scene === 'game' && turn === 'enemy' && gameStatus === 'playing') {
          const timer = setTimeout(() => {
            monsterAttack();
          }, 1200); 
          return () => clearTimeout(timer);
        }
      }, [turn, gameStatus, scene]);

      const monsterAttack = () => {
        setMonsterAttacking(true);
        setTimeout(() => {
          const baseDmg = 8 + Math.floor(level * 1.5);
          const variance = Math.floor(Math.random() * 4) - 2;
          let rawDamage = Math.max(1, baseDmg + variance);
          
          let actualDamage = rawDamage;
          if (shield > 0) {
            if (shield >= rawDamage) {
              actualDamage = 0;
              setShield(prev => prev - rawDamage);
              addFloatingText("æ ¼æŒ¡!", "block");
              addLog(`${currentMonster.name} æ”»å‡»é€ æˆ ${rawDamage} ç‚¹ä¼¤å®³ï¼Œè¢«æŠ¤ç›¾å®Œå…¨æŠµæ¶ˆï¼`, 'info');
            } else {
              actualDamage = rawDamage - shield;
              setShield(0);
              addLog(`${currentMonster.name} æ”»å‡»é€ æˆ ${rawDamage} ç‚¹ä¼¤å®³ï¼ŒæŠ¤ç›¾æŠµæ¶ˆäº†éƒ¨åˆ†ä¼¤å®³ã€‚`, 'enemy');
            }
          } else {
            addLog(`${currentMonster.name} æ”»å‡»é€ æˆ ${rawDamage} ç‚¹ä¼¤å®³ï¼`, 'enemy');
          }

          if (soundEnabled && actualDamage > 0) playSound('hit');
          if (soundEnabled && actualDamage === 0) playSound('block');

          if (actualDamage > 0) {
            setPlayerHp(prev => {
              const newHp = Math.max(0, prev - actualDamage);
              if (newHp <= 0) {
                setGameStatus('lost');
                addLog("ä½ çš„ç”Ÿå‘½å€¼å½’é›¶ï¼Œæˆ˜æ–—å¤±è´¥ã€‚", 'enemy');
                if (soundEnabled) playSound('attack_normal'); 
              }
              return newHp;
            });
            addFloatingText(`-${actualDamage}`, 'damage');
          }

          setMonsterAttacking(false);
          
          if (playerHp > actualDamage) { 
            setTurn('player');
            setMp(prev => Math.min(10, prev + 1)); 
          }
        }, 400); 
      };

      // ç»„åˆæ£€æµ‹
      useEffect(() => {
        if (selectedIndices.length < 2) {
          setComboResult(null);
          return;
        }

        const selectedChars = selectedIndices.map(idx => hand[idx].char);
        const key = [...selectedChars].sort().join('');
        
        if (COMBINATION_DB[key]) {
          setComboResult(COMBINATION_DB[key]);
        } else {
          setComboResult(null);
        }
      }, [selectedIndices, hand]);

      const handleCardClick = (index) => {
        if (gameStatus !== 'playing' || turn !== 'player') return;
        setHintIndices([]);
        setSelectedIndices(prev => {
          if (prev.includes(index)) {
            return prev.filter(i => i !== index);
          } else {
            return [...prev, index];
          }
        });
      };

      const calculateFinalDamage = (combo) => {
        let dmg = combo.power + (character.dmgBonus || 0);
        if (currentMonster.weakness !== 'none' && combo.type === currentMonster.weakness) {
          dmg = Math.floor(dmg * 1.5);
        }
        return dmg;
      };

      const handleAttack = () => {
        if (!comboResult || turn !== 'player') return;

        let damage = calculateFinalDamage(comboResult);
        const usedChars = selectedIndices.map(i => hand[i].char).join('+');
        
        let isCrit = false;
        let weaknessLog = '';
        if (currentMonster.weakness !== 'none' && comboResult.type === currentMonster.weakness) {
          isCrit = true;
          weaknessLog = ' (å±æ€§å…‹åˆ¶!)';
        }

        const rarity = getRarity(comboResult.type);
        if (soundEnabled) {
          if (isCrit) playSound('crit');
          else if (rarity === 'epic') playSound('attack_epic');
          else if (rarity === 'rare') playSound('attack_rare');
          else playSound('attack_normal');
        }

        addLog(`ç»„åˆã€${usedChars}ã€‘=ã€${comboResult.char.split('/')[0]}ã€‘ï¼Œé€ æˆ ${damage} ç‚¹ä¼¤å®³${weaknessLog}ï¼`, 'player');

        setMonsterHp(prev => {
          const newHp = prev - damage;
          if (newHp <= 0) {
            setTimeout(() => handleMonsterDefeat(), 300); 
            return 0;
          }
          return newHp;
        });

        setMonsterHit(true);
        setTimeout(() => setMonsterHit(false), 300);
        
        addFloatingText(`-${damage}`, 'damage', isCrit ? 'crit' : rarity);

        if (comboResult.type === 'heal' || comboResult.type === 'defense') {
          const healAmount = 10;
          setPlayerHp(prev => Math.min(maxPlayerHp, prev + healAmount));
          addFloatingText(`+${healAmount}`, 'heal');
          addLog(`è§¦å‘ç‰¹æ•ˆï¼Œå›å¤ ${healAmount} ç‚¹ç”Ÿå‘½å€¼ã€‚`, 'player');
          if (soundEnabled) playSound('heal');
        }

        if (!discoveredWords.includes(comboResult.char)) {
          setDiscoveredWords(prev => [...prev, comboResult.char]);
          addFloatingText("æ–°å­—è§£é”!", "achievement");
        }

        const remainingHand = hand.filter((_, idx) => !selectedIndices.includes(idx));
        const maxHandSize = 7 + (character.handSizeBonus || 0);
        const cardsToDraw = maxHandSize - remainingHand.length;
        
        const cardsDrawn = drawCards(remainingHand, cardsToDraw);
        setHand([...remainingHand, ...cardsDrawn]);
        
        setSelectedIndices([]);
        setComboResult(null);
        setHintIndices([]);
        
        const mpGain = selectedIndices.length >= 3 ? 2 : 1;
        setMp(prev => Math.min(10, prev + mpGain));

        if (monsterHp - damage > 0) {
          setTurn('enemy');
        }
      };

      const useSkill = () => {
        if (mp < character.skillCost || turn !== 'player') {
          addFloatingText("å¢¨æ°´ä¸è¶³!", "block");
          return;
        }
        
        if (soundEnabled) playSound('heal');
        setMp(prev => prev - character.skillCost);
        addLog(`ä½¿ç”¨äº†æŠ€èƒ½ã€${character.skillName}ã€‘ï¼Œæ¶ˆè€— ${character.skillCost} å¢¨æ°´ã€‚`, 'player');
        
        const effects = character.skillEffect({ 
          monsterHp, playerHp, maxPlayerHp 
        });

        if (effects.monsterHp !== undefined) {
          const dmg = monsterHp - effects.monsterHp;
          setMonsterHp(effects.monsterHp);
          addFloatingText(`-${dmg}`, 'damage');
          addLog(`æŠ€èƒ½é€ æˆ ${dmg} ç‚¹ä¼¤å®³ã€‚`, 'player');
          setMonsterHit(true);
          setTimeout(() => setMonsterHit(false), 300);
          if (effects.monsterHp <= 0) setTimeout(() => handleMonsterDefeat(), 300);
        }
        
        if (effects.playerHp !== undefined) {
          const heal = effects.playerHp - playerHp;
          setPlayerHp(effects.playerHp);
          addFloatingText(`+${heal}`, 'heal');
          addLog(`æŠ€èƒ½å›å¤ ${heal} ç‚¹ç”Ÿå‘½å€¼ã€‚`, 'player');
        }
      };

      const handleDefend = () => {
        if (turn !== 'player') return;
        if (soundEnabled) playSound('block');
        
        const defenseAmount = 10; 
        setShield(prev => prev + defenseAmount);
        
        addFloatingText("é˜²å¾¡!", "block"); 
        addLog(`è¿›å…¥é˜²å¾¡å§¿æ€ï¼Œè·å¾— ${defenseAmount} ç‚¹æŠ¤ç›¾ï¼Œå¹¶é‡ç½®æ‰‹ç‰Œã€‚`, 'info');
        
        setHand(drawCards([], 7 + (character.handSizeBonus || 0)));
        setSelectedIndices([]);
        setHintIndices([]);
        setComboResult(null);
        setTurn('enemy');
      };

      const useHint = () => {
        if (hintsLeft <= 0 || turn !== 'player') {
          addFloatingText("æ¬¡æ•°ä¸è¶³!", "block");
          return;
        }
        if (soundEnabled) playSound('select');

        const solutionIndices = findFirstValidCombo(hand);
        if (solutionIndices) {
          setHintIndices(solutionIndices);
          setHintsLeft(prev => prev - 1);
          addFloatingText("å‘ç°ç»„åˆ!", "info");
          addLog("ä½¿ç”¨äº†æç¤ºåŠŸèƒ½ã€‚", 'info');
        } else {
          addFloatingText("æ— è§£ï¼Œè¯·é˜²å¾¡", "info");
          addLog("æç¤ºï¼šå½“å‰æ‰‹ç‰Œæ— æ³•ç»„åˆï¼Œå»ºè®®ä½¿ç”¨é˜²å¾¡ã€‚", 'info');
        }
      };

      const handleMonsterDefeat = () => {
        if (soundEnabled) playSound('win');
        addFloatingText("èƒœåˆ©!", "achievement");
        addLog(`å‡»è´¥äº† ${currentMonster.name}ï¼`, 'info');
        
        if (hintsLeft < MAX_HINTS) {
          setHintsLeft(prev => prev + 1);
        }

        setTimeout(() => {
          const newLevel = level + 1;
          setLevel(newLevel);
          
          let nextMonster = MONSTER_TYPES[(newLevel - 1) % MONSTER_TYPES.length];
          if (newLevel % 5 === 0) nextMonster = MONSTER_TYPES[3]; 
          setCurrentMonster(nextMonster);

          const nextMaxHp = Math.floor(50 * Math.pow(1.15, newLevel - 1) * nextMonster.hpScale);
          setMaxMonsterHp(nextMaxHp);
          setMonsterHp(nextMaxHp);
          
          setPlayerHp(prev => Math.min(maxPlayerHp, prev + 20));
          setMp(prev => Math.min(10, prev + 2)); 
          setShield(0); 
          setTurn('player');
          
          addLog(`è¿›å…¥ç¬¬ ${newLevel} å…³ï¼Œé­é‡ ${nextMonster.name} (HP: ${nextMaxHp})`, 'info');
        }, 1500);
      };

      const addFloatingText = (text, type, rarity) => {
        const id = getUniqueId();
        setFloatingTexts(prev => [...prev, { id, text, type, rarity }]);
        setTimeout(() => {
          setFloatingTexts(prev => prev.filter(ft => ft.id !== id));
        }, 1000);
      };

      const startGame = (selectedChar) => {
        // åˆå§‹åŒ–éŸ³æ•ˆä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
        initAudio();
        
        setCharacter(selectedChar);
        const baseHp = 100 + (selectedChar.hpBonus || 0);
        setPlayerHp(baseHp);
        setMaxPlayerHp(baseHp);
        setLevel(1);
        setMonsterHp(50);
        setMaxMonsterHp(50);
        setHand(drawCards([], 7 + (selectedChar.handSizeBonus || 0)));
        setSelectedIndices([]);
        setHintIndices([]);
        setGameStatus('playing');
        setTurn('player');
        setHintsLeft(3);
        setMp(3);
        setShield(0);
        setBattleLogs([]);
        setCurrentMonster(MONSTER_TYPES[0]);
        setScene('game');
        addLog(`æ¸¸æˆå¼€å§‹ï¼é€‰æ‹©äº†è‹±é›„ï¼š${selectedChar.name}`, 'info');
        addLog(`é­é‡äº† ${MONSTER_TYPES[0].name}`, 'info');
      };

      // è§’è‰²é€‰æ‹©ç»„ä»¶
      const CharacterSelect = ({ onSelect }) => (
        <div className="flex flex-col items-center justify-center h-full space-y-6 animate-fade-in p-4 overflow-y-auto">
          <h2 className="text-3xl font-bold text-stone-800 mb-4">é€‰æ‹©ä½ çš„è‹±é›„</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 w-full max-w-4xl">
            {CHARACTERS.map(char => (
              <button
                key={char.id}
                onClick={() => { playSound('select'); onSelect(char); }}
                className="bg-white border-2 border-stone-200 rounded-xl p-6 hover:border-amber-500 hover:shadow-xl transition flex flex-col items-center text-center gap-3 group"
              >
                <div className="text-4xl p-4 bg-stone-100 rounded-full group-hover:scale-110 transition">{char.icon}</div>
                <h3 className="text-xl font-bold">{char.name}</h3>
                <p className="text-sm text-stone-500">{char.desc}</p>
                <div className="mt-2 w-full bg-amber-50 rounded p-2 text-xs text-amber-800">
                  <strong>æŠ€èƒ½: {char.skillName}</strong><br/>
                  {char.skillDesc}<br/>
                  (æ¶ˆè€— {char.skillCost} å¢¨æ°´)
                </div>
              </button>
            ))}
          </div>
        </div>
      );

      return (
        <div className="fixed inset-0 bg-stone-100 font-sans text-stone-800 flex flex-col overflow-hidden select-none">
          
          {floatingTexts.map(ft => (
            <FloatingText key={ft.id} text={ft.text} type={ft.type} rarity={ft.rarity} />
          ))}

          {/* é¡¶éƒ¨çŠ¶æ€æ  */}
          {scene === 'game' && (
            <header className="bg-stone-800 text-amber-50 px-4 py-2 shadow-lg flex justify-between items-center z-30 h-14 shrink-0">
              <div className="flex items-center gap-3">
                <button onClick={() => setScene('menu')} className="hover:text-amber-400 transition">
                  <Home size={20} />
                </button>
                <div className="flex items-center gap-2">
                  <span className="text-xl">{character.icon}</span>
                  <div className="hidden md:block text-sm font-bold">{character.name}</div>
                </div>
                <button onClick={() => setSoundEnabled(!soundEnabled)} className="text-stone-400 hover:text-white">
                  {soundEnabled ? <Volume2 size={16} /> : <VolumeX size={16} />}
                </button>
              </div>
              
              <div className="flex gap-3 text-sm items-center font-mono">
                <div className="flex items-center gap-1 text-yellow-400">
                  <Trophy size={16} /> Lv.{level}
                </div>
                <button 
                  onClick={() => setShowLogs(true)}
                  className="bg-stone-700 p-1.5 rounded hover:bg-stone-600 relative"
                  title="æˆ˜æ–—è®°å½•"
                >
                  <FileText size={16} />
                  <div className="absolute top-0 right-0 w-2 h-2 bg-red-500 rounded-full animate-ping opacity-75"></div>
                </button>
                <button 
                  onClick={() => setShowDictionary(!showDictionary)}
                  className="bg-stone-700 p-1.5 rounded hover:bg-stone-600"
                >
                  <BookOpen size={16} />
                </button>
              </div>
            </header>
          )}

          <main className="flex-1 relative flex flex-col items-center w-full max-w-2xl mx-auto overflow-hidden">
            
            {scene === 'menu' && (
              <div className="flex flex-col items-center justify-center h-full space-y-8 animate-fade-in">
                <div className="text-center space-y-2">
                  <h1 className="text-4xl md:text-6xl font-bold text-stone-800 tracking-wider font-serif">
                    æ±‰å­—é­”æ³•æˆ˜
                  </h1>
                  <div className="text-stone-500 tracking-[0.5em] text-sm md:text-base">- åæ—éƒ¨é¦– -</div>
                </div>
                <button 
                  onClick={() => { initAudio(); playSound('select'); setScene('charSelect'); }}
                  className="bg-amber-600 hover:bg-amber-700 text-white text-xl font-bold py-4 px-12 rounded-2xl shadow-lg transition transform hover:scale-105 active:scale-95 flex items-center gap-2 animate-bounce-slow"
                >
                  <Play fill="currentColor" /> å¼€å§‹å†’é™©
                </button>
                <div className="flex gap-4">
                  <button onClick={() => setScene('instructions')} className="text-stone-500 hover:underline">æ¸¸æˆè¯´æ˜</button>
                  <button onClick={() => setShowDictionary(true)} className="text-stone-500 hover:underline">å›¾é‰´</button>
                </div>
              </div>
            )}

            {scene === 'charSelect' && (
              <CharacterSelect onSelect={startGame} />
            )}

            {scene === 'instructions' && (
              <div className="p-6 overflow-y-auto h-full w-full">
                <h2 className="text-2xl font-bold mb-4">æ¸¸æˆè¯´æ˜</h2>
                <p className="mb-4">é€šè¿‡ç»„åˆåæ—éƒ¨é¦–ï¼Œé‡Šæ”¾æ±‰å­—é­”æ³•æ”»å‡»æ€ªç‰©ï¼</p>
                <ul className="list-disc pl-5 space-y-2 text-stone-700">
                  <li><strong>æ”»å‡»ï¼š</strong>é€‰ä¸­2ä¸ªæˆ–æ›´å¤šå¡ç‰Œç»„æˆæ±‰å­—ã€‚</li>
                  <li><strong>ç»“æ„ï¼š</strong>ç•™æ„æ±‰å­—çš„ç»“æ„ï¼ˆå·¦å³ã€ä¸Šä¸‹ã€åŒ…å›´ï¼‰ï¼Œåˆç†ç»„åˆå¨åŠ›æ›´å¤§ï¼</li>
                  <li><strong>å±æ€§å…‹åˆ¶ï¼š</strong>è§‚å¯Ÿæ€ªç‰©çš„å¼±ç‚¹ï¼Œç”¨å¯¹åº”çš„åæ—ï¼ˆå¦‚â€œæ°µâ€å…‹â€œå¢¨è¿¹å¦–â€ï¼‰é€ æˆ<span className="text-purple-600 font-bold">æš´å‡»</span>ï¼</li>
                  <li><strong>å¢¨æ°´ï¼š</strong>ç»„åˆæ±‰å­—å¯æ¢å¤å¢¨æ°´ï¼Œå¢¨æ°´ç”¨äºé‡Šæ”¾è§’è‰²å¿…æ€æŠ€ã€‚</li>
                  <li><strong>é˜²å¾¡ï¼š</strong>æ‰‹ç‰Œä¸ä½³æ—¶ç‚¹å‡»â€œç›¾ç‰Œâ€å›¾æ ‡ï¼Œå¯å¼ƒç‰Œé‡æŠ½å¹¶è·å¾—æŠ¤ç›¾ã€‚</li>
                </ul>
                <button onClick={() => setScene('menu')} className="mt-8 bg-stone-200 px-6 py-2 rounded-lg font-bold w-full">è¿”å›</button>
              </div>
            )}

            {scene === 'game' && (
              <>
                <div className="flex-[0.4] w-full flex flex-col items-center justify-center relative bg-stone-100 border-b border-stone-200">
                  <div className={`absolute top-2 px-3 py-1 rounded-full text-xs font-bold shadow-sm transition-all
                    ${turn === 'player' ? 'bg-blue-100 text-blue-800' : 'bg-red-100 text-red-800 scale-110'}
                  `}>
                    {turn === 'player' ? 'ä½ çš„å›åˆ' : 'æ•Œæ–¹è¡ŒåŠ¨'}
                  </div>
                  <div className="w-full flex justify-center items-center p-4">
                    {gameStatus === 'playing' && (
                      <Monster 
                        level={level} 
                        hp={monsterHp} 
                        maxHp={maxMonsterHp} 
                        isAttacking={monsterAttacking}
                        onHitAnim={monsterHit}
                        turn={turn}
                        monsterType={currentMonster}
                      />
                    )}
                  </div>
                </div>

                <div className="flex-[0.6] w-full bg-white flex flex-col relative shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)]">
                  
                  <div className="h-12 bg-stone-50 border-b border-stone-100 flex items-center justify-between px-4">
                    <div className="flex items-center gap-3">
                        <div className="flex items-center gap-2 bg-white px-2 py-1 rounded-lg border border-stone-200 shadow-sm">
                          <Heart className="text-red-500 fill-current w-4 h-4" />
                          <span className="font-bold text-lg leading-none">{playerHp}/{maxPlayerHp}</span>
                        </div>
                        {shield > 0 && (
                          <div className="flex items-center gap-1 bg-stone-200 px-2 py-1 rounded-lg animate-fade-in">
                            <Shield className="text-stone-600 w-3 h-3" />
                            <span className="font-bold text-sm text-stone-600">{shield}</span>
                          </div>
                        )}
                    </div>
                    
                    <div className="flex items-center gap-1">
                        {[...Array(10)].map((_, i) => (
                          <div key={i} className={`w-1.5 h-3 rounded-sm transition-colors ${i < mp ? 'bg-blue-600' : 'bg-stone-300'}`} />
                        ))}
                    </div>
                  </div>

                  <div className="h-14 flex items-center justify-between px-4 border-b border-stone-100">
                    <button 
                      onClick={useSkill}
                      disabled={turn !== 'player' || mp < character.skillCost}
                      className={`
                        flex items-center gap-2 px-4 py-1.5 rounded-full font-bold text-sm transition-all
                        ${mp >= character.skillCost && turn === 'player'
                          ? 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white shadow-md active:scale-95' 
                          : 'bg-stone-200 text-stone-400 cursor-not-allowed'}
                      `}
                    >
                      <Zap size={14} className={mp >= character.skillCost ? "fill-yellow-300 text-yellow-300" : ""} />
                      {character.skillName} ({character.skillCost})
                    </button>

                    <div className="flex gap-2">
                      <button 
                        onClick={useHint}
                        disabled={turn !== 'player' || hintsLeft <= 0}
                        className="p-2 rounded-full bg-yellow-50 text-yellow-600 hover:bg-yellow-100 disabled:opacity-50 relative"
                      >
                        <Lightbulb size={20} />
                        <span className="absolute -top-1 -right-1 bg-red-500 text-white text-[10px] w-4 h-4 rounded-full flex items-center justify-center">{hintsLeft}</span>
                      </button>
                      <button 
                        onClick={handleDefend}
                        disabled={turn !== 'player'}
                        className="p-2 rounded-full bg-stone-100 text-stone-600 hover:bg-stone-200 disabled:opacity-50"
                        title="é˜²å¾¡"
                      >
                        <Shield size={20} />
                      </button>
                    </div>
                  </div>

                  <div className="h-16 flex items-center justify-center bg-stone-50/50">
                    {comboResult ? (
                      <button 
                        onClick={handleAttack}
                        className={`
                          animate-bounce-slow flex items-center gap-3 px-6 py-2 rounded-full shadow-lg active:scale-95 transition border-2 group
                          ${getRarity(comboResult.type) === 'epic' ? 'bg-amber-100 border-amber-500 ring-2 ring-amber-300' : 
                            getRarity(comboResult.type) === 'rare' ? 'bg-indigo-50 border-indigo-400 ring-1 ring-indigo-200' :
                            'bg-white border-stone-300'}
                        `}
                      >
                        <div className="opacity-50 group-hover:opacity-100 transition-opacity">
                          <StructureIcon type={comboResult.struct} />
                        </div>
                        <span className={`text-3xl font-serif font-bold ${
                          getRarity(comboResult.type) === 'epic' ? 'text-amber-800 drop-shadow-sm' : 
                          getRarity(comboResult.type) === 'rare' ? 'text-indigo-800' : 'text-stone-800'
                        }`}>
                          {comboResult.char.split('/')[0]}
                        </span>
                        <div className="flex flex-col items-start leading-none">
                          <span className={`text-xs font-bold ${
                            getRarity(comboResult.type) === 'epic' ? 'text-amber-800' : 
                            getRarity(comboResult.type) === 'rare' ? 'text-indigo-700' : 'text-stone-500'
                          }`}>{comboResult.desc}</span>
                          <span className="text-xs font-bold text-red-600 mt-0.5">
                            å¨åŠ›: {calculateFinalDamage(comboResult)}
                            {currentMonster.weakness !== 'none' && comboResult.type === currentMonster.weakness && <span className="text-[10px] ml-1 text-purple-600 animate-pulse">(å…‹åˆ¶!)</span>}
                          </span>
                        </div>
                      </button>
                    ) : (
                      <div className="text-stone-400 text-sm italic flex items-center gap-2">
                        <span>ç‚¹å‡»å¡ç‰Œç»„åˆ</span>
                        <span className="text-xs bg-stone-200 px-1 rounded">å·¦å³</span>
                        <span className="text-xs bg-stone-200 px-1 rounded">ä¸Šä¸‹</span>
                      </div>
                    )}
                  </div>

                  <div className="flex-1 overflow-y-auto p-2 bg-stone-100 inner-shadow">
                    <div className="flex flex-wrap justify-center content-start gap-2 pb-4">
                      {hand.map((card, idx) => (
                        <Card 
                          key={card.id} 
                          char={card.char} 
                          selected={selectedIndices.includes(idx)}
                          isHinted={hintIndices.includes(idx)}
                          onClick={() => handleCardClick(idx)}
                          disabled={gameStatus !== 'playing' || turn !== 'player'}
                        />
                      ))}
                    </div>
                  </div>
                </div>
                
                {gameStatus !== 'playing' && (
                  <div className="absolute inset-0 bg-stone-900/85 backdrop-blur-sm z-50 flex flex-col items-center justify-center text-white p-6 text-center animate-fade-in">
                    <h2 className="text-5xl font-bold mb-4 font-serif text-amber-400">
                      {gameStatus === 'won' ? 'å¤§è·å…¨èƒœ' : 'è´¥åŒ—'}
                    </h2>
                    <p className="mb-8 text-lg text-stone-300">
                      {gameStatus === 'won' ? 'ä½ çš„æ–‡é‡‡éœ‡æƒŠäº†å¦–ç•Œï¼' : 'è¿˜éœ€è¦å¤šåŠ ç»ƒä¹ ä¹¦æ³•...'}
                    </p>
                    <div className="flex gap-4">
                      <button 
                        onClick={() => { playSound('select'); startGame(character); }} 
                        className="bg-amber-600 hover:bg-amber-700 font-bold py-3 px-8 rounded-full flex items-center gap-2 transition"
                      >
                        <RotateCcw /> å†æ¥ä¸€å±€
                      </button>
                      <button 
                        onClick={() => setScene('menu')}
                        className="bg-stone-700 hover:bg-stone-600 font-bold py-3 px-6 rounded-full"
                      >
                        ä¸»èœå•
                      </button>
                    </div>
                  </div>
                )}
              </>
            )}
          </main>

          {showLogs && <BattleLogModal logs={battleLogs} onClose={() => setShowLogs(false)} />}

          {/* å›¾é‰´æ¨¡æ€æ¡† */}
          {showDictionary && (
            <div className="fixed inset-0 bg-stone-900/95 z-[60] flex items-center justify-center p-4">
              <div className="bg-white w-full max-w-2xl h-[80vh] rounded-2xl flex flex-col overflow-hidden shadow-2xl">
                <div className="p-4 bg-stone-100 border-b flex justify-between items-center">
                  <h3 className="font-bold text-lg flex items-center gap-2 text-stone-800">
                    <BookOpen size={20} className="text-amber-600"/> æ±‰å­—å®å…¸
                  </h3>
                  <button onClick={() => setShowDictionary(false)} className="text-stone-500 hover:text-stone-800 font-bold px-3">X</button>
                </div>
                <div className="p-4 overflow-y-auto grid grid-cols-4 sm:grid-cols-5 md:grid-cols-6 gap-2">
                  {Object.entries(COMBINATION_DB).map(([key, val]) => {
                    const isDiscovered = discoveredWords.includes(val.char);
                    const rarity = getRarity(val.type);
                    const config = getRarityConfig(rarity);
                    return (
                      <div key={key} className={`
                        aspect-square rounded-lg flex flex-col items-center justify-center border relative
                        ${isDiscovered 
                          ? `${config.bg} ${config.border} ${config.color}` 
                          : 'bg-stone-100 border-stone-200 text-stone-300'}
                      `}>
                        {isDiscovered && (
                          <div className="absolute top-1 left-1 opacity-50">
                            <StructureIcon type={val.struct} size={12}/>
                          </div>
                        )}
                        <div className="text-xl md:text-2xl font-serif font-bold">{isDiscovered ? val.char.split('/')[0] : '?'}</div>
                        {isDiscovered && rarity !== 'normal' && (
                          <div className={`absolute top-1 right-1 flex items-center gap-0.5 text-[8px] font-bold uppercase`}>
                            {config.icon}
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // æ¸²æŸ“æ ¹ç»„ä»¶
    const root = createRoot(document.getElementById('root'));
    root.render(<HanziMagicBattle />);
  </script>
</body>
</html>
